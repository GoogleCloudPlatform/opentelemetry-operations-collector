// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/filter"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// AttributeGpuClockViolation specifies the value gpu.clock.violation attribute.
type AttributeGpuClockViolation int

const (
	_ AttributeGpuClockViolation = iota
	AttributeGpuClockViolationPower
	AttributeGpuClockViolationThermal
	AttributeGpuClockViolationSyncBoost
	AttributeGpuClockViolationBoardLimit
	AttributeGpuClockViolationLowUtil
	AttributeGpuClockViolationReliability
	AttributeGpuClockViolationAppClock
	AttributeGpuClockViolationBaseClock
)

// String returns the string representation of the AttributeGpuClockViolation.
func (av AttributeGpuClockViolation) String() string {
	switch av {
	case AttributeGpuClockViolationPower:
		return "power"
	case AttributeGpuClockViolationThermal:
		return "thermal"
	case AttributeGpuClockViolationSyncBoost:
		return "sync_boost"
	case AttributeGpuClockViolationBoardLimit:
		return "board_limit"
	case AttributeGpuClockViolationLowUtil:
		return "low_util"
	case AttributeGpuClockViolationReliability:
		return "reliability"
	case AttributeGpuClockViolationAppClock:
		return "app_clock"
	case AttributeGpuClockViolationBaseClock:
		return "base_clock"
	}
	return ""
}

// MapAttributeGpuClockViolation is a helper map of string to AttributeGpuClockViolation attribute value.
var MapAttributeGpuClockViolation = map[string]AttributeGpuClockViolation{
	"power":       AttributeGpuClockViolationPower,
	"thermal":     AttributeGpuClockViolationThermal,
	"sync_boost":  AttributeGpuClockViolationSyncBoost,
	"board_limit": AttributeGpuClockViolationBoardLimit,
	"low_util":    AttributeGpuClockViolationLowUtil,
	"reliability": AttributeGpuClockViolationReliability,
	"app_clock":   AttributeGpuClockViolationAppClock,
	"base_clock":  AttributeGpuClockViolationBaseClock,
}

// AttributeGpuErrorType specifies the value gpu.error.type attribute.
type AttributeGpuErrorType int

const (
	_ AttributeGpuErrorType = iota
	AttributeGpuErrorTypeSbe
	AttributeGpuErrorTypeDbe
)

// String returns the string representation of the AttributeGpuErrorType.
func (av AttributeGpuErrorType) String() string {
	switch av {
	case AttributeGpuErrorTypeSbe:
		return "sbe"
	case AttributeGpuErrorTypeDbe:
		return "dbe"
	}
	return ""
}

// MapAttributeGpuErrorType is a helper map of string to AttributeGpuErrorType attribute value.
var MapAttributeGpuErrorType = map[string]AttributeGpuErrorType{
	"sbe": AttributeGpuErrorTypeSbe,
	"dbe": AttributeGpuErrorTypeDbe,
}

// AttributeGpuMemoryState specifies the value gpu.memory.state attribute.
type AttributeGpuMemoryState int

const (
	_ AttributeGpuMemoryState = iota
	AttributeGpuMemoryStateUsed
	AttributeGpuMemoryStateFree
	AttributeGpuMemoryStateReserved
)

// String returns the string representation of the AttributeGpuMemoryState.
func (av AttributeGpuMemoryState) String() string {
	switch av {
	case AttributeGpuMemoryStateUsed:
		return "used"
	case AttributeGpuMemoryStateFree:
		return "free"
	case AttributeGpuMemoryStateReserved:
		return "reserved"
	}
	return ""
}

// MapAttributeGpuMemoryState is a helper map of string to AttributeGpuMemoryState attribute value.
var MapAttributeGpuMemoryState = map[string]AttributeGpuMemoryState{
	"used":     AttributeGpuMemoryStateUsed,
	"free":     AttributeGpuMemoryStateFree,
	"reserved": AttributeGpuMemoryStateReserved,
}

// AttributeGpuPipe specifies the value gpu.pipe attribute.
type AttributeGpuPipe int

const (
	_ AttributeGpuPipe = iota
	AttributeGpuPipeTensor
	AttributeGpuPipeFp64
	AttributeGpuPipeFp32
	AttributeGpuPipeFp16
)

// String returns the string representation of the AttributeGpuPipe.
func (av AttributeGpuPipe) String() string {
	switch av {
	case AttributeGpuPipeTensor:
		return "tensor"
	case AttributeGpuPipeFp64:
		return "fp64"
	case AttributeGpuPipeFp32:
		return "fp32"
	case AttributeGpuPipeFp16:
		return "fp16"
	}
	return ""
}

// MapAttributeGpuPipe is a helper map of string to AttributeGpuPipe attribute value.
var MapAttributeGpuPipe = map[string]AttributeGpuPipe{
	"tensor": AttributeGpuPipeTensor,
	"fp64":   AttributeGpuPipeFp64,
	"fp32":   AttributeGpuPipeFp32,
	"fp16":   AttributeGpuPipeFp16,
}

// AttributeNetworkIoDirection specifies the value network.io.direction attribute.
type AttributeNetworkIoDirection int

const (
	_ AttributeNetworkIoDirection = iota
	AttributeNetworkIoDirectionTransmit
	AttributeNetworkIoDirectionReceive
)

// String returns the string representation of the AttributeNetworkIoDirection.
func (av AttributeNetworkIoDirection) String() string {
	switch av {
	case AttributeNetworkIoDirectionTransmit:
		return "transmit"
	case AttributeNetworkIoDirectionReceive:
		return "receive"
	}
	return ""
}

// MapAttributeNetworkIoDirection is a helper map of string to AttributeNetworkIoDirection attribute value.
var MapAttributeNetworkIoDirection = map[string]AttributeNetworkIoDirection{
	"transmit": AttributeNetworkIoDirectionTransmit,
	"receive":  AttributeNetworkIoDirectionReceive,
}

var MetricsInfo = metricsInfo{
	GpuDcgmClockFrequency: metricInfo{
		Name: "gpu.dcgm.clock.frequency",
	},
	GpuDcgmClockThrottleDurationTime: metricInfo{
		Name: "gpu.dcgm.clock.throttle_duration.time",
	},
	GpuDcgmCodecDecoderUtilization: metricInfo{
		Name: "gpu.dcgm.codec.decoder.utilization",
	},
	GpuDcgmCodecEncoderUtilization: metricInfo{
		Name: "gpu.dcgm.codec.encoder.utilization",
	},
	GpuDcgmEccErrors: metricInfo{
		Name: "gpu.dcgm.ecc_errors",
	},
	GpuDcgmEnergyConsumption: metricInfo{
		Name: "gpu.dcgm.energy_consumption",
	},
	GpuDcgmMemoryBandwidthUtilization: metricInfo{
		Name: "gpu.dcgm.memory.bandwidth_utilization",
	},
	GpuDcgmMemoryBytesUsed: metricInfo{
		Name: "gpu.dcgm.memory.bytes_used",
	},
	GpuDcgmNvlinkIo: metricInfo{
		Name: "gpu.dcgm.nvlink.io",
	},
	GpuDcgmPcieIo: metricInfo{
		Name: "gpu.dcgm.pcie.io",
	},
	GpuDcgmPipeUtilization: metricInfo{
		Name: "gpu.dcgm.pipe.utilization",
	},
	GpuDcgmSmOccupancy: metricInfo{
		Name: "gpu.dcgm.sm.occupancy",
	},
	GpuDcgmSmUtilization: metricInfo{
		Name: "gpu.dcgm.sm.utilization",
	},
	GpuDcgmTemperature: metricInfo{
		Name: "gpu.dcgm.temperature",
	},
	GpuDcgmUtilization: metricInfo{
		Name: "gpu.dcgm.utilization",
	},
	GpuDcgmXidErrors: metricInfo{
		Name: "gpu.dcgm.xid_errors",
	},
}

type metricsInfo struct {
	GpuDcgmClockFrequency             metricInfo
	GpuDcgmClockThrottleDurationTime  metricInfo
	GpuDcgmCodecDecoderUtilization    metricInfo
	GpuDcgmCodecEncoderUtilization    metricInfo
	GpuDcgmEccErrors                  metricInfo
	GpuDcgmEnergyConsumption          metricInfo
	GpuDcgmMemoryBandwidthUtilization metricInfo
	GpuDcgmMemoryBytesUsed            metricInfo
	GpuDcgmNvlinkIo                   metricInfo
	GpuDcgmPcieIo                     metricInfo
	GpuDcgmPipeUtilization            metricInfo
	GpuDcgmSmOccupancy                metricInfo
	GpuDcgmSmUtilization              metricInfo
	GpuDcgmTemperature                metricInfo
	GpuDcgmUtilization                metricInfo
	GpuDcgmXidErrors                  metricInfo
}

type metricInfo struct {
	Name string
}

type metricGpuDcgmClockFrequency struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.clock.frequency metric with initial data.
func (m *metricGpuDcgmClockFrequency) init() {
	m.data.SetName("gpu.dcgm.clock.frequency")
	m.data.SetDescription("Multiprocessor clock frequency.")
	m.data.SetUnit("Hz")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmClockFrequency) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmClockFrequency) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmClockFrequency) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmClockFrequency(cfg MetricConfig) metricGpuDcgmClockFrequency {
	m := metricGpuDcgmClockFrequency{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmClockThrottleDurationTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.clock.throttle_duration.time metric with initial data.
func (m *metricGpuDcgmClockThrottleDurationTime) init() {
	m.data.SetName("gpu.dcgm.clock.throttle_duration.time")
	m.data.SetDescription("Clock throttle total duration.")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricGpuDcgmClockThrottleDurationTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, gpuClockViolationAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("gpu.clock.violation", gpuClockViolationAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmClockThrottleDurationTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmClockThrottleDurationTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmClockThrottleDurationTime(cfg MetricConfig) metricGpuDcgmClockThrottleDurationTime {
	m := metricGpuDcgmClockThrottleDurationTime{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmCodecDecoderUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.codec.decoder.utilization metric with initial data.
func (m *metricGpuDcgmCodecDecoderUtilization) init() {
	m.data.SetName("gpu.dcgm.codec.decoder.utilization")
	m.data.SetDescription("Decoder utilization.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmCodecDecoderUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmCodecDecoderUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmCodecDecoderUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmCodecDecoderUtilization(cfg MetricConfig) metricGpuDcgmCodecDecoderUtilization {
	m := metricGpuDcgmCodecDecoderUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmCodecEncoderUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.codec.encoder.utilization metric with initial data.
func (m *metricGpuDcgmCodecEncoderUtilization) init() {
	m.data.SetName("gpu.dcgm.codec.encoder.utilization")
	m.data.SetDescription("Encoder utilization.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmCodecEncoderUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmCodecEncoderUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmCodecEncoderUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmCodecEncoderUtilization(cfg MetricConfig) metricGpuDcgmCodecEncoderUtilization {
	m := metricGpuDcgmCodecEncoderUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmEccErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.ecc_errors metric with initial data.
func (m *metricGpuDcgmEccErrors) init() {
	m.data.SetName("gpu.dcgm.ecc_errors")
	m.data.SetDescription("Data corruption errors.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricGpuDcgmEccErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, gpuErrorTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("gpu.error.type", gpuErrorTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmEccErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmEccErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmEccErrors(cfg MetricConfig) metricGpuDcgmEccErrors {
	m := metricGpuDcgmEccErrors{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmEnergyConsumption struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.energy_consumption metric with initial data.
func (m *metricGpuDcgmEnergyConsumption) init() {
	m.data.SetName("gpu.dcgm.energy_consumption")
	m.data.SetDescription("Total energy consumption for the GPU in J since the driver was last reloaded.")
	m.data.SetUnit("J")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricGpuDcgmEnergyConsumption) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmEnergyConsumption) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmEnergyConsumption) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmEnergyConsumption(cfg MetricConfig) metricGpuDcgmEnergyConsumption {
	m := metricGpuDcgmEnergyConsumption{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmMemoryBandwidthUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.memory.bandwidth_utilization metric with initial data.
func (m *metricGpuDcgmMemoryBandwidthUtilization) init() {
	m.data.SetName("gpu.dcgm.memory.bandwidth_utilization")
	m.data.SetDescription("Fraction of cycles data was being sent or received from GPU memory.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmMemoryBandwidthUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmMemoryBandwidthUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmMemoryBandwidthUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmMemoryBandwidthUtilization(cfg MetricConfig) metricGpuDcgmMemoryBandwidthUtilization {
	m := metricGpuDcgmMemoryBandwidthUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmMemoryBytesUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.memory.bytes_used metric with initial data.
func (m *metricGpuDcgmMemoryBytesUsed) init() {
	m.data.SetName("gpu.dcgm.memory.bytes_used")
	m.data.SetDescription("Current number of GPU memory bytes used by state. Summing the values of all states yields the total GPU memory space.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricGpuDcgmMemoryBytesUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, gpuMemoryStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("gpu.memory.state", gpuMemoryStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmMemoryBytesUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmMemoryBytesUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmMemoryBytesUsed(cfg MetricConfig) metricGpuDcgmMemoryBytesUsed {
	m := metricGpuDcgmMemoryBytesUsed{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmNvlinkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.nvlink.io metric with initial data.
func (m *metricGpuDcgmNvlinkIo) init() {
	m.data.SetName("gpu.dcgm.nvlink.io")
	m.data.SetDescription("The number of bytes sent over NVLink, not including protocol headers.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricGpuDcgmNvlinkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, networkIoDirectionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("network.io.direction", networkIoDirectionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmNvlinkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmNvlinkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmNvlinkIo(cfg MetricConfig) metricGpuDcgmNvlinkIo {
	m := metricGpuDcgmNvlinkIo{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmPcieIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.pcie.io metric with initial data.
func (m *metricGpuDcgmPcieIo) init() {
	m.data.SetName("gpu.dcgm.pcie.io")
	m.data.SetDescription("The number of bytes sent over the PCIe bus, including both protocol headers and data payloads.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricGpuDcgmPcieIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, networkIoDirectionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("network.io.direction", networkIoDirectionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmPcieIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmPcieIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmPcieIo(cfg MetricConfig) metricGpuDcgmPcieIo {
	m := metricGpuDcgmPcieIo{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmPipeUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.pipe.utilization metric with initial data.
func (m *metricGpuDcgmPipeUtilization) init() {
	m.data.SetName("gpu.dcgm.pipe.utilization")
	m.data.SetDescription("Fraction of cycles the corresponding GPU pipe was active, averaged over time and all multiprocessors.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricGpuDcgmPipeUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, gpuPipeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("gpu.pipe", gpuPipeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmPipeUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmPipeUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmPipeUtilization(cfg MetricConfig) metricGpuDcgmPipeUtilization {
	m := metricGpuDcgmPipeUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmSmOccupancy struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.sm.occupancy metric with initial data.
func (m *metricGpuDcgmSmOccupancy) init() {
	m.data.SetName("gpu.dcgm.sm.occupancy")
	m.data.SetDescription("Fraction of the number of warps resident on a multiprocessor, averaged over all multiprocessors.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmSmOccupancy) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmSmOccupancy) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmSmOccupancy) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmSmOccupancy(cfg MetricConfig) metricGpuDcgmSmOccupancy {
	m := metricGpuDcgmSmOccupancy{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmSmUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.sm.utilization metric with initial data.
func (m *metricGpuDcgmSmUtilization) init() {
	m.data.SetName("gpu.dcgm.sm.utilization")
	m.data.SetDescription("Fraction of time at least one warp was active on a multiprocessor, averaged over all multiprocessors.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmSmUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmSmUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmSmUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmSmUtilization(cfg MetricConfig) metricGpuDcgmSmUtilization {
	m := metricGpuDcgmSmUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmTemperature struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.temperature metric with initial data.
func (m *metricGpuDcgmTemperature) init() {
	m.data.SetName("gpu.dcgm.temperature")
	m.data.SetDescription("Current temperature readings for the device, in ËšC.")
	m.data.SetUnit("Cel")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmTemperature) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmTemperature) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmTemperature) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmTemperature(cfg MetricConfig) metricGpuDcgmTemperature {
	m := metricGpuDcgmTemperature{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.utilization metric with initial data.
func (m *metricGpuDcgmUtilization) init() {
	m.data.SetName("gpu.dcgm.utilization")
	m.data.SetDescription("Ratio of time the graphics engine is active.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricGpuDcgmUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmUtilization(cfg MetricConfig) metricGpuDcgmUtilization {
	m := metricGpuDcgmUtilization{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricGpuDcgmXidErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills gpu.dcgm.xid_errors metric with initial data.
func (m *metricGpuDcgmXidErrors) init() {
	m.data.SetName("gpu.dcgm.xid_errors")
	m.data.SetDescription("XID errors.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricGpuDcgmXidErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, gpuErrorXidAttributeValue int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutInt("gpu.error.xid", gpuErrorXidAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricGpuDcgmXidErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricGpuDcgmXidErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricGpuDcgmXidErrors(cfg MetricConfig) metricGpuDcgmXidErrors {
	m := metricGpuDcgmXidErrors{config: cfg}

	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                                  MetricsBuilderConfig // config of the metrics builder.
	startTime                               pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity                         int                  // maximum observed number of metrics per resource.
	metricsBuffer                           pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo                               component.BuildInfo  // contains version information.
	resourceAttributeIncludeFilter          map[string]filter.Filter
	resourceAttributeExcludeFilter          map[string]filter.Filter
	metricGpuDcgmClockFrequency             metricGpuDcgmClockFrequency
	metricGpuDcgmClockThrottleDurationTime  metricGpuDcgmClockThrottleDurationTime
	metricGpuDcgmCodecDecoderUtilization    metricGpuDcgmCodecDecoderUtilization
	metricGpuDcgmCodecEncoderUtilization    metricGpuDcgmCodecEncoderUtilization
	metricGpuDcgmEccErrors                  metricGpuDcgmEccErrors
	metricGpuDcgmEnergyConsumption          metricGpuDcgmEnergyConsumption
	metricGpuDcgmMemoryBandwidthUtilization metricGpuDcgmMemoryBandwidthUtilization
	metricGpuDcgmMemoryBytesUsed            metricGpuDcgmMemoryBytesUsed
	metricGpuDcgmNvlinkIo                   metricGpuDcgmNvlinkIo
	metricGpuDcgmPcieIo                     metricGpuDcgmPcieIo
	metricGpuDcgmPipeUtilization            metricGpuDcgmPipeUtilization
	metricGpuDcgmSmOccupancy                metricGpuDcgmSmOccupancy
	metricGpuDcgmSmUtilization              metricGpuDcgmSmUtilization
	metricGpuDcgmTemperature                metricGpuDcgmTemperature
	metricGpuDcgmUtilization                metricGpuDcgmUtilization
	metricGpuDcgmXidErrors                  metricGpuDcgmXidErrors
}

// MetricBuilderOption applies changes to default metrics builder.
type MetricBuilderOption interface {
	apply(*MetricsBuilder)
}

type metricBuilderOptionFunc func(mb *MetricsBuilder)

func (mbof metricBuilderOptionFunc) apply(mb *MetricsBuilder) {
	mbof(mb)
}

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) MetricBuilderOption {
	return metricBuilderOptionFunc(func(mb *MetricsBuilder) {
		mb.startTime = startTime
	})
}
func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.Settings, options ...MetricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                                  mbc,
		startTime:                               pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                           pmetric.NewMetrics(),
		buildInfo:                               settings.BuildInfo,
		metricGpuDcgmClockFrequency:             newMetricGpuDcgmClockFrequency(mbc.Metrics.GpuDcgmClockFrequency),
		metricGpuDcgmClockThrottleDurationTime:  newMetricGpuDcgmClockThrottleDurationTime(mbc.Metrics.GpuDcgmClockThrottleDurationTime),
		metricGpuDcgmCodecDecoderUtilization:    newMetricGpuDcgmCodecDecoderUtilization(mbc.Metrics.GpuDcgmCodecDecoderUtilization),
		metricGpuDcgmCodecEncoderUtilization:    newMetricGpuDcgmCodecEncoderUtilization(mbc.Metrics.GpuDcgmCodecEncoderUtilization),
		metricGpuDcgmEccErrors:                  newMetricGpuDcgmEccErrors(mbc.Metrics.GpuDcgmEccErrors),
		metricGpuDcgmEnergyConsumption:          newMetricGpuDcgmEnergyConsumption(mbc.Metrics.GpuDcgmEnergyConsumption),
		metricGpuDcgmMemoryBandwidthUtilization: newMetricGpuDcgmMemoryBandwidthUtilization(mbc.Metrics.GpuDcgmMemoryBandwidthUtilization),
		metricGpuDcgmMemoryBytesUsed:            newMetricGpuDcgmMemoryBytesUsed(mbc.Metrics.GpuDcgmMemoryBytesUsed),
		metricGpuDcgmNvlinkIo:                   newMetricGpuDcgmNvlinkIo(mbc.Metrics.GpuDcgmNvlinkIo),
		metricGpuDcgmPcieIo:                     newMetricGpuDcgmPcieIo(mbc.Metrics.GpuDcgmPcieIo),
		metricGpuDcgmPipeUtilization:            newMetricGpuDcgmPipeUtilization(mbc.Metrics.GpuDcgmPipeUtilization),
		metricGpuDcgmSmOccupancy:                newMetricGpuDcgmSmOccupancy(mbc.Metrics.GpuDcgmSmOccupancy),
		metricGpuDcgmSmUtilization:              newMetricGpuDcgmSmUtilization(mbc.Metrics.GpuDcgmSmUtilization),
		metricGpuDcgmTemperature:                newMetricGpuDcgmTemperature(mbc.Metrics.GpuDcgmTemperature),
		metricGpuDcgmUtilization:                newMetricGpuDcgmUtilization(mbc.Metrics.GpuDcgmUtilization),
		metricGpuDcgmXidErrors:                  newMetricGpuDcgmXidErrors(mbc.Metrics.GpuDcgmXidErrors),
		resourceAttributeIncludeFilter:          make(map[string]filter.Filter),
		resourceAttributeExcludeFilter:          make(map[string]filter.Filter),
	}
	if mbc.ResourceAttributes.GpuModel.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["gpu.model"] = filter.CreateFilter(mbc.ResourceAttributes.GpuModel.MetricsInclude)
	}
	if mbc.ResourceAttributes.GpuModel.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["gpu.model"] = filter.CreateFilter(mbc.ResourceAttributes.GpuModel.MetricsExclude)
	}
	if mbc.ResourceAttributes.GpuNumber.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["gpu.number"] = filter.CreateFilter(mbc.ResourceAttributes.GpuNumber.MetricsInclude)
	}
	if mbc.ResourceAttributes.GpuNumber.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["gpu.number"] = filter.CreateFilter(mbc.ResourceAttributes.GpuNumber.MetricsExclude)
	}
	if mbc.ResourceAttributes.GpuUUID.MetricsInclude != nil {
		mb.resourceAttributeIncludeFilter["gpu.uuid"] = filter.CreateFilter(mbc.ResourceAttributes.GpuUUID.MetricsInclude)
	}
	if mbc.ResourceAttributes.GpuUUID.MetricsExclude != nil {
		mb.resourceAttributeExcludeFilter["gpu.uuid"] = filter.CreateFilter(mbc.ResourceAttributes.GpuUUID.MetricsExclude)
	}

	for _, op := range options {
		op.apply(mb)
	}
	return mb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption interface {
	apply(pmetric.ResourceMetrics)
}

type resourceMetricsOptionFunc func(pmetric.ResourceMetrics)

func (rmof resourceMetricsOptionFunc) apply(rm pmetric.ResourceMetrics) {
	rmof(rm)
}

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	})
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return resourceMetricsOptionFunc(func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	})
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(options ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName(ScopeName)
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricGpuDcgmClockFrequency.emit(ils.Metrics())
	mb.metricGpuDcgmClockThrottleDurationTime.emit(ils.Metrics())
	mb.metricGpuDcgmCodecDecoderUtilization.emit(ils.Metrics())
	mb.metricGpuDcgmCodecEncoderUtilization.emit(ils.Metrics())
	mb.metricGpuDcgmEccErrors.emit(ils.Metrics())
	mb.metricGpuDcgmEnergyConsumption.emit(ils.Metrics())
	mb.metricGpuDcgmMemoryBandwidthUtilization.emit(ils.Metrics())
	mb.metricGpuDcgmMemoryBytesUsed.emit(ils.Metrics())
	mb.metricGpuDcgmNvlinkIo.emit(ils.Metrics())
	mb.metricGpuDcgmPcieIo.emit(ils.Metrics())
	mb.metricGpuDcgmPipeUtilization.emit(ils.Metrics())
	mb.metricGpuDcgmSmOccupancy.emit(ils.Metrics())
	mb.metricGpuDcgmSmUtilization.emit(ils.Metrics())
	mb.metricGpuDcgmTemperature.emit(ils.Metrics())
	mb.metricGpuDcgmUtilization.emit(ils.Metrics())
	mb.metricGpuDcgmXidErrors.emit(ils.Metrics())

	for _, op := range options {
		op.apply(rm)
	}
	for attr, filter := range mb.resourceAttributeIncludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && !filter.Matches(val.AsString()) {
			return
		}
	}
	for attr, filter := range mb.resourceAttributeExcludeFilter {
		if val, ok := rm.Resource().Attributes().Get(attr); ok && filter.Matches(val.AsString()) {
			return
		}
	}

	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(options ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(options...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordGpuDcgmClockFrequencyDataPoint adds a data point to gpu.dcgm.clock.frequency metric.
func (mb *MetricsBuilder) RecordGpuDcgmClockFrequencyDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmClockFrequency.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmClockThrottleDurationTimeDataPoint adds a data point to gpu.dcgm.clock.throttle_duration.time metric.
func (mb *MetricsBuilder) RecordGpuDcgmClockThrottleDurationTimeDataPoint(ts pcommon.Timestamp, val float64, gpuClockViolationAttributeValue AttributeGpuClockViolation) {
	mb.metricGpuDcgmClockThrottleDurationTime.recordDataPoint(mb.startTime, ts, val, gpuClockViolationAttributeValue.String())
}

// RecordGpuDcgmCodecDecoderUtilizationDataPoint adds a data point to gpu.dcgm.codec.decoder.utilization metric.
func (mb *MetricsBuilder) RecordGpuDcgmCodecDecoderUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmCodecDecoderUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmCodecEncoderUtilizationDataPoint adds a data point to gpu.dcgm.codec.encoder.utilization metric.
func (mb *MetricsBuilder) RecordGpuDcgmCodecEncoderUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmCodecEncoderUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmEccErrorsDataPoint adds a data point to gpu.dcgm.ecc_errors metric.
func (mb *MetricsBuilder) RecordGpuDcgmEccErrorsDataPoint(ts pcommon.Timestamp, val int64, gpuErrorTypeAttributeValue AttributeGpuErrorType) {
	mb.metricGpuDcgmEccErrors.recordDataPoint(mb.startTime, ts, val, gpuErrorTypeAttributeValue.String())
}

// RecordGpuDcgmEnergyConsumptionDataPoint adds a data point to gpu.dcgm.energy_consumption metric.
func (mb *MetricsBuilder) RecordGpuDcgmEnergyConsumptionDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmEnergyConsumption.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmMemoryBandwidthUtilizationDataPoint adds a data point to gpu.dcgm.memory.bandwidth_utilization metric.
func (mb *MetricsBuilder) RecordGpuDcgmMemoryBandwidthUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmMemoryBandwidthUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmMemoryBytesUsedDataPoint adds a data point to gpu.dcgm.memory.bytes_used metric.
func (mb *MetricsBuilder) RecordGpuDcgmMemoryBytesUsedDataPoint(ts pcommon.Timestamp, val int64, gpuMemoryStateAttributeValue AttributeGpuMemoryState) {
	mb.metricGpuDcgmMemoryBytesUsed.recordDataPoint(mb.startTime, ts, val, gpuMemoryStateAttributeValue.String())
}

// RecordGpuDcgmNvlinkIoDataPoint adds a data point to gpu.dcgm.nvlink.io metric.
func (mb *MetricsBuilder) RecordGpuDcgmNvlinkIoDataPoint(ts pcommon.Timestamp, val int64, networkIoDirectionAttributeValue AttributeNetworkIoDirection) {
	mb.metricGpuDcgmNvlinkIo.recordDataPoint(mb.startTime, ts, val, networkIoDirectionAttributeValue.String())
}

// RecordGpuDcgmPcieIoDataPoint adds a data point to gpu.dcgm.pcie.io metric.
func (mb *MetricsBuilder) RecordGpuDcgmPcieIoDataPoint(ts pcommon.Timestamp, val int64, networkIoDirectionAttributeValue AttributeNetworkIoDirection) {
	mb.metricGpuDcgmPcieIo.recordDataPoint(mb.startTime, ts, val, networkIoDirectionAttributeValue.String())
}

// RecordGpuDcgmPipeUtilizationDataPoint adds a data point to gpu.dcgm.pipe.utilization metric.
func (mb *MetricsBuilder) RecordGpuDcgmPipeUtilizationDataPoint(ts pcommon.Timestamp, val float64, gpuPipeAttributeValue AttributeGpuPipe) {
	mb.metricGpuDcgmPipeUtilization.recordDataPoint(mb.startTime, ts, val, gpuPipeAttributeValue.String())
}

// RecordGpuDcgmSmOccupancyDataPoint adds a data point to gpu.dcgm.sm.occupancy metric.
func (mb *MetricsBuilder) RecordGpuDcgmSmOccupancyDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmSmOccupancy.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmSmUtilizationDataPoint adds a data point to gpu.dcgm.sm.utilization metric.
func (mb *MetricsBuilder) RecordGpuDcgmSmUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmSmUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmTemperatureDataPoint adds a data point to gpu.dcgm.temperature metric.
func (mb *MetricsBuilder) RecordGpuDcgmTemperatureDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmTemperature.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmUtilizationDataPoint adds a data point to gpu.dcgm.utilization metric.
func (mb *MetricsBuilder) RecordGpuDcgmUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	mb.metricGpuDcgmUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordGpuDcgmXidErrorsDataPoint adds a data point to gpu.dcgm.xid_errors metric.
func (mb *MetricsBuilder) RecordGpuDcgmXidErrorsDataPoint(ts pcommon.Timestamp, val int64, gpuErrorXidAttributeValue int64) {
	mb.metricGpuDcgmXidErrors.recordDataPoint(mb.startTime, ts, val, gpuErrorXidAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...MetricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op.apply(mb)
	}
}
