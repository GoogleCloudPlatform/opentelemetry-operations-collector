receivers:
  # scrape all metrics at 1m interval
  hostmetrics:
    collection_interval: 1m
    scrapers:
      memory:
      cpu:
      disk:
      filesystem:
      network:
      swap:
      process:
      load:
  # add receivers to extend the ability for MySQL, JVM and Apache

processors:
  # convert from OpenTelemetry metric formats to Cloud Monitoring formats
  metricstransform:
    transforms:
      - metric_name: system.memory.usage
        action: insert
        new_name: memory/bytes_used
        operations:
          # aggregate state label values: slab_reclaimable & slab_unreclaimable -> slab
          - action: aggregate_label_values
            label: state
            aggregated_values: [slab_reclaimable, slab_unreclaimable]
            new_value: slab
            aggregation_type: sum
      - metric_name: system.filesystem.usage
        action: insert
        new_name: disk/bytes_used
      - metric_name: system.disk.merged
        action: insert
        new_name: disk/merged_operations
      - metric_name: system.cpu.load_average.1m
        action: insert
        new_name: cpu/load_1m
      - metric_name: system.cpu.load_average.5m
        action: insert
        new_name: cpu/load_5m
      - metric_name: system.cpu.load_average.15m
        action: insert
        new_name: cpu/load_15m

exporters:
  # export to Cloud Monitoring using the agent prefix
  stackdriver:
    metric_prefix: agent.googleapis.com/

  # for debugging
  logging:
  file:
    path: ./metrics.json

service:
  pipelines:
    metrics:
      receivers: [hostmetrics]
      processors: [metricstransform]
      exporters: [stackdriver, logging] # add 'file' to enable output to a file